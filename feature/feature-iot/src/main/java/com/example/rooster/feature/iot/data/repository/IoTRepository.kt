package com.example.rooster.feature.iot.data.repository

import com.example.rooster.core.common.Result
import com.example.rooster.feature.iot.data.model.*
import kotlinx.coroutines.flow.Flow

/**
 * Repository interface for handling IoT related data operations.
 * This includes fetching sensor data, device information, alerts, analytics, and automation settings.
 */
interface IoTRepository {

    //region Device Info
    /**
     * Retrieves a flow of all registered IoT device information.
     * This flow will emit updates whenever device information changes in the remote source.
     * @return A [Flow] emitting [Result] which contains a list of [DeviceInfo] on success.
     */
    fun getAllDeviceInfos(): Flow<Result<List<DeviceInfo>>>

    /**
     * Retrieves a flow of specific IoT device information.
     * @param deviceId The unique ID of the device.
     * @return A [Flow] emitting [Result] which contains the [DeviceInfo] or null if not found.
     */
    fun getDeviceInfo(deviceId: String): Flow<Result<DeviceInfo?>>

    /**
     * Forces a refresh of device information from the remote source, updating the local cache.
     */
    suspend fun refreshDeviceInfos()
    //endregion

    //region Sensor Readings
    /**
     * Gets a flow of recent temperature readings for a specific device.
     * @param deviceId The ID of the device.
     * @return A [Flow] emitting [Result] of a list of [TemperatureReading].
     */
    fun getTemperatureReadings(deviceId: String): Flow<Result<List<TemperatureReading>>>

    /**
     * Gets temperature readings for a specific device within a given time range.
     * Primarily fetches from the local cache.
     * @param deviceId The ID of the device.
     * @param startTime The start of the time range (epoch milliseconds).
     * @param endTime The end of the time range (epoch milliseconds).
     * @return A [Flow] emitting [Result] of a list of [TemperatureReading].
     */
    fun getTemperatureReadingsInRange(deviceId: String, startTime: Long, endTime: Long): Flow<Result<List<TemperatureReading>>>

    /**
     * Refreshes temperature readings for a device, optionally fetching from remote and updating local cache.
     * @param deviceId The ID of the device.
     * @param fromRemote If true, fetches from remote source; otherwise, might just re-query local.
     */
    suspend fun refreshTemperatureReadings(deviceId: String, fromRemote: Boolean = true)

    fun getHumidityReadings(deviceId: String): Flow<Result<List<HumidityReading>>>
    fun getHumidityReadingsInRange(deviceId: String, startTime: Long, endTime: Long): Flow<Result<List<HumidityReading>>>
    suspend fun refreshHumidityReadings(deviceId: String, fromRemote: Boolean = true)

    fun getFeedLevelReadings(deviceId: String): Flow<Result<List<FeedLevelReading>>>
    fun getFeedLevelReadingsInRange(deviceId: String, startTime: Long, endTime: Long): Flow<Result<List<FeedLevelReading>>>
    suspend fun refreshFeedLevelReadings(deviceId: String, fromRemote: Boolean = true)

    fun getWaterConsumptionReadings(deviceId: String): Flow<Result<List<WaterConsumptionReading>>>
    fun getWaterConsumptionReadingsInRange(deviceId: String, startTime: Long, endTime: Long): Flow<Result<List<WaterConsumptionReading>>>
    suspend fun refreshWaterConsumptionReadings(deviceId: String, fromRemote: Boolean = true)

    fun getLightLevelReadings(deviceId: String): Flow<Result<List<LightLevelReading>>>
    fun getLightLevelReadingsInRange(deviceId: String, startTime: Long, endTime: Long): Flow<Result<List<LightLevelReading>>>
    suspend fun refreshLightLevelReadings(deviceId: String, fromRemote: Boolean = true)
    //endregion

    //region Alerts
    /**
     * Gets a flow of all alerts, typically ordered by timestamp.
     * @return A [Flow] emitting [Result] of a list of [AlertInfo].
     */
    fun getAllAlerts(): Flow<Result<List<AlertInfo>>>

    /**
     * Gets a flow of unacknowledged alerts.
     * @return A [Flow] emitting [Result] of a list of [AlertInfo].
     */
    fun getUnacknowledgedAlerts(): Flow<Result<List<AlertInfo>>>

    /**
     * Refreshes alerts, optionally fetching from remote and updating local cache.
     * @param fromRemote If true, fetches from remote source.
     */
    suspend fun refreshAlerts(fromRemote: Boolean = true)

    /**
     * Marks an alert as acknowledged.
     * @param alertId The ID of the alert to acknowledge.
     * @return [Result.Success] if successful, [Result.Error] otherwise.
     */
    suspend fun acknowledgeAlert(alertId: String): Result<Unit>

    /**
     * Records a new alert, typically generated by the app based on sensor data.
     * @param alertInfo The [AlertInfo] object to record.
     * @return [Result.Success] if successful, [Result.Error] otherwise.
     */
    suspend fun recordAlert(alertInfo: AlertInfo): Result<Unit>
    //endregion

    //region Device Configuration
    /**
     * Gets a flow of the configuration for a specific device.
     * @param deviceId The ID of the device.
     * @return A [Flow] emitting [Result] of [DeviceConfig] or null.
     */
    fun getDeviceConfig(deviceId: String): Flow<Result<DeviceConfig?>>

    /**
     * Updates the configuration for a device.
     * This typically updates the local cache and marks it for synchronization.
     * @param config The [DeviceConfig] to update.
     * @return [Result.Success] if successful, [Result.Error] otherwise.
     */
    suspend fun updateDeviceConfig(config: DeviceConfig): Result<Unit>

    /**
     * Synchronizes any pending local device configuration changes to the remote source.
     * @return [Result.Success] if successful, [Result.Error] otherwise.
     */
    suspend fun syncDeviceConfigs(): Result<Unit>
    //endregion

    //region Advanced Analytics Data
    /**
     * Gets a flow of production forecasts.
     * @param farmId Optional ID of the farm.
     * @param flockId Optional ID of the flock.
     * @return A [Flow] emitting [Result] of a list of [ProductionForecast].
     */
    fun getProductionForecasts(farmId: String?, flockId: String?): Flow<Result<List<ProductionForecast>>>
    suspend fun refreshProductionForecasts(farmId: String?, flockId: String?)

    fun getPerformancePredictions(farmId: String?, flockId: String?): Flow<Result<List<PerformancePrediction>>>
    suspend fun refreshPerformancePredictions(farmId: String?, flockId: String?)

    fun getFeedOptimizationRecommendations(farmId: String?, flockId: String?): Flow<Result<List<FeedOptimizationRecommendation>>>
    suspend fun refreshFeedOptimizationRecommendations(farmId: String?, flockId: String?)

    fun getHealthTrends(farmId: String?, flockId: String?): Flow<Result<List<HealthTrend>>>
    suspend fun refreshHealthTrends(farmId: String?, flockId: String?)
    //endregion

    //region Smart Automation Settings
    /**
     * Gets a flow of feeding schedules.
     * @param farmId Optional ID of the farm.
     * @param flockId Optional ID of the flock.
     * @return A [Flow] emitting [Result] of a list of [FeedingSchedule].
     */
    fun getFeedingSchedules(farmId: String?, flockId: String?): Flow<Result<List<FeedingSchedule>>>

    /**
     * Updates a feeding schedule both remotely and locally.
     * @param schedule The [FeedingSchedule] to update.
     * @return [Result.Success] if successful, [Result.Error] otherwise.
     */
    suspend fun updateFeedingSchedule(schedule: FeedingSchedule): Result<Unit>
    suspend fun refreshFeedingSchedules(farmId: String?, flockId: String?)

    fun getClimateSettings(farmId: String?, shedId: String?): Flow<Result<List<ClimateSettings>>>
    suspend fun updateClimateSettings(settings: ClimateSettings): Result<Unit>
    suspend fun refreshClimateSettings(farmId: String?, shedId: String?)

    fun getMaintenanceReminders(farmId: String?, deviceId: String?): Flow<Result<List<MaintenanceReminder>>>
    suspend fun updateMaintenanceReminder(reminder: MaintenanceReminder): Result<Unit>
    suspend fun addMaintenanceReminder(reminder: MaintenanceReminder): Result<Unit>
    suspend fun refreshMaintenanceReminders(farmId: String?, deviceId: String?)
    //endregion

    // MQTT Connection Status (if repository manages MQTT connection)
    // fun getMqttConnectionStatus(): Flow<Boolean>
    // suspend fun connectMqtt()
    // suspend fun disconnectMqtt()
}
