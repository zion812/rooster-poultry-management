package com.example.rooster.feature.farm.domain.usecase

import com.example.rooster.core.common.Result // Import common Result
import com.example.rooster.feature.farm.domain.model.FlockRegistrationData
import javax.inject.Inject // Added for Hilt

interface RegisterFlockUseCase {
    suspend operator fun invoke(data: FlockRegistrationData): Result<Unit> // Ensure this is core.common.Result
}

// For mapping
import com.example.rooster.core.common.model.Flock as CanonicalFlock
import com.example.rooster.core.common.model.AgeGroup as CanonicalAgeGroup
import com.example.rooster.core.common.model.FlockType as CanonicalFlockType
import com.example.rooster.core.common.model.VaccinationRecord as CanonicalVaccinationRecord
// Potentially Gender enum if it needs mapping, assuming it's compatible for now from feature-farm model to core-common.

// Add @Inject for Hilt if this use case is injected into ViewModels
class RegisterFlockUseCaseImpl @Inject constructor(
    // Changed to inject the canonical FarmRepository from core-data
    private val farmRepository: com.example.rooster.core.data.repository.FarmRepository
) : RegisterFlockUseCase {
    override suspend operator fun invoke(data: FlockRegistrationData): Result<Unit> {
        // 1. Map FlockRegistrationData (from feature-farm) to CanonicalFlock (from core-common)
        val canonicalFlock = CanonicalFlock(
            // id is usually generated by backend/repository, so pass empty or let repo handle
            farmId = data.ownerId, // Assuming ownerId in FlockRegistrationData is the farmId
            name = data.breed ?: "Unnamed Flock", // FlockRegistryScreen doesn't have a separate "Flock Name" field currently, using breed. This needs review.
                                                // The FlockRegistryScreen from user's analysis is comprehensive, but the ViewModel I read earlier didn't show a name field.
                                                // Let's assume breed can serve as name for now or a generic name.
            breed = data.breed ?: "",
            flockType = mapFlockType(data.ageGroup), // Approximate mapping from AgeGroup
            totalBirds = data.size ?: 0, // Assuming 'size' in FlockRegistrationData means bird count
            activeBirds = data.size ?: 0, // Assuming all are active initially
            establishedDate = data.dateOfBirth?.time ?: System.currentTimeMillis(), // Or a specific acquisition date field

            isTraceable = data.registryType == RegistryType.TRACEABLE,
            ageGroup = mapAgeGroup(data.ageGroup),
            sireId = data.fatherId,
            damId = data.motherId,
            dateOfBirthTimestamp = data.dateOfBirth?.time,
            placeOfBirth = data.placeOfBirth,
            identificationTag = data.identification,
            colors = data.colors,
            currentWeight = data.weight,
            height = data.height,
            specialty = data.specialty,
            proofImageUrls = data.proofs,
            vaccinationHistory = data.vaccinationRecords?.map { mapVaccinationRecord(it) } // Requires VaccinationRecord in feature-farm and its mapper
            // genderDistribution: Needs mapping if data.gender is for the whole flock
        )

        // 2. Call the repository method
        val result = farmRepository.addFlock(canonicalFlock)

        // 3. Adapt Result<Flock> to Result<Unit>
        return result.fold(
            onSuccess = { Result.Success(Unit) },
            onFailure = { exception -> Result.Error(exception) }
        )
    }

    // Helper mapping functions (these are simplified and might need more robust logic)
    private fun mapAgeGroup(featureFarmAgeGroup: com.example.rooster.feature.farm.domain.model.AgeGroup): CanonicalAgeGroup {
        return when (featureFarmAgeGroup) {
            com.example.rooster.feature.farm.domain.model.AgeGroup.CHICKS -> CanonicalAgeGroup.CHICKS
            com.example.rooster.feature.farm.domain.model.AgeGroup.WEEKS_0_5 -> CanonicalAgeGroup.WEEKS_0_5
            com.example.rooster.feature.farm.domain.model.AgeGroup.WEEKS_5_5MONTHS -> CanonicalAgeGroup.WEEKS_5_5MONTHS
            com.example.rooster.feature.farm.domain.model.AgeGroup.MONTHS_5_12PLUS -> CanonicalAgeGroup.MONTHS_5_12PLUS
            com.example.rooster.feature.farm.domain.model.AgeGroup.UNKNOWN -> CanonicalAgeGroup.UNKNOWN
        }
    }

    private fun mapFlockType(featureFarmAgeGroup: com.example.rooster.feature.farm.domain.model.AgeGroup): CanonicalFlockType {
        // This is an approximation. FlockType should ideally be a direct input in FlockRegistrationData.
        return when (featureFarmAgeGroup) {
            com.example.rooster.feature.farm.domain.model.AgeGroup.CHICKS -> CanonicalFlockType.CHICK
            com.example.rooster.feature.farm.domain.model.AgeGroup.WEEKS_0_5 -> CanonicalFlockType.PULLET // Or CHICK
            com.example.rooster.feature.farm.domain.model.AgeGroup.WEEKS_5_5MONTHS -> CanonicalFlockType.PULLET
            else -> CanonicalFlockType.MIXED // Default or could be BREEDING/LAYER based on other info
        }
    }

    // This assumes feature.farm.domain.model.VaccinationRecord exists and is similar enough
    // If not, this mapping needs to be based on what data.vaccinationRecords contains.
    // For now, I'll assume a placeholder structure for feature.farm.domain.model.VaccinationRecord
    // based on FlockRegistrationData.kt's mention of it.
    private fun mapVaccinationRecord(featureRecord: com.example.rooster.feature.farm.domain.model.VaccinationRecord?): CanonicalVaccinationRecord {
        // This is a placeholder. The actual structure of feature.farm.domain.model.VaccinationRecord is unknown.
        // Let's assume it has 'name' and 'date' (as Date).
        return CanonicalVaccinationRecord(
            vaccineName = featureRecord?.name ?: "Unknown Vaccine", // Placeholder access
            dateTimestamp = featureRecord?.date?.time ?: System.currentTimeMillis(), // Placeholder access
            notes = featureRecord?.notes // Placeholder access
        )
    }
}

// Placeholder for feature.farm.domain.model.VaccinationRecord if its definition is not available to me
// This is just for the mapping function to compile. The actual model should be used.
private data class VaccinationRecord(val name: String?, val date: Date?, val notes: String?)